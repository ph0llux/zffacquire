// - STD
use std::{
    fs::{File},
    process::exit,
};

// - extern crates
extern crate clap;
extern crate rand;
extern crate zff;

// - modules
mod lib;

// - internal
use crate::lib::{
    hrs_parser,
    constants::*,
};
use zff::{
    header::*,
    EncryptionAlgorithm,
    CompressionAlgorithm,
    HashType,
    KDFScheme,
    PBEScheme,
    ZffCreatorPhysical,
    Encryption,
    Signature,
    SignatureFlag,
    constants::{
        DEFAULT_COMPRESSION_RATIO_THRESHOLD,
        DEFAULT_HEADER_VERSION_COMPRESSION_HEADER,
        DEFAULT_HEADER_VERSION_DESCRIPTION_HEADER,
        DEFAULT_HEADER_VERSION_PBE_HEADER,
        DEFAULT_HEADER_VERSION_ENCRYPTION_HEADER,
        DEFAULT_HEADER_VERSION_MAIN_HEADER,
        DEFAULT_HEADER_VERSION_OBJECT_HEADER,
        INITIAL_OBJECT_NUMBER,
    },
};

// - external
use clap::{
    AppSettings,
    Parser,
    Subcommand,
    ArgEnum,
};
use rand::{Rng};
use ed25519_dalek::Keypair;
use toml;
use base64;

#[derive(Parser)]
#[clap(about, version, author)]
struct Cli {

    /// A general description of all data, which are inside the zff file(s).
    #[clap(short='D', long="description-notes", global=true, required=false)]
    description_notes: Option<String>,

    /// The input file. This should be your device to dump. This field is REQUIRED.
    #[clap(short='i', long="inputfile", global=true, required=false)]
    inputfile: String,

    /// The the name/path of the output-file WITHOUT file extension. E.g. \"/home/ph0llux/sda_dump\". File extension will be added automatically. This field is REQUIRED.
    #[clap(short='o', long="outputfile", global=true, required=false)]
    outputfile: String,

    /// sets the compression algorithm. Default is zstd.
    #[clap(short='z', long="compression-algorithm", global=true, required=false, arg_enum, default_value="zstd")]
    compression_algorithm: CompressionAlgorithmValues,

    /// sets the compression level. Default is 3. This option doesn't has any effect while using the lz4 compression algorithm.
    #[clap(short='l', long="compression-level", global=true, required=false, default_value="3")]
    compression_level: u8,

    /// The compression ratio threshold. Default is 1.05.
    #[clap(short='T', long="compression-threshold", global=true, required=false, default_value=DEFAULT_COMPRESSION_RATIO_THRESHOLD)]
    compression_threshold: f32,

    /// The segment size of the output-file(s). Default is 0 (=the output image will never be splitted into segments).
    #[clap(short='s', long="segment-size", global=true, required=false, default_value="0")]
    segment_size: String,

    /// The chunk size. Default is 32kB. The chunksize have to be greater than the segment size.
    #[clap(short='C', long, global=true, required=false, default_value="32KB", arg_enum)]
    chunk_size: ChunkSize,

    /// Sets an encryption password
    #[clap(short='p', long="encryption-password", global=true, required=false)]
    encryption_password: Option<String>,

    /// Sets the key derivation function for the password. Default is [pbkdf2_sha256_aes256cbc].
    #[clap(short='K', long="password-kdf", global=true, required=false, arg_enum, default_value="pbkdf2-sha256-aes256-cbc")]
    password_kdf: PasswordKdfValues,

    /// Sets the encryption algorithm. Default is [aes256-gcm-siv].
    #[clap(short='E', long="encryption-algorithm", global=true, required=false, arg_enum, default_value="aes256gcmsiv")]
    encryption_algorithm: EncryptionAlgorithmValues,

    /// Encrypts the data AND parts of the main header (e.g. the "description fields", like 'examiner name', 'case number', ...)
    #[clap(short='H', long="encrypted-header", global=true, requires("encryption-password"))]
    encrypted_header: bool,

    /// This option adds an additional hash algorithm to calculate. You can use this option multiple times.
    #[clap(short='d', long="hash-algorithm", global=true, required=false, arg_enum)]
    hash_algorithm: Vec<HashAlgorithmValues>,

    /// Sign all data with an autogenerated or given secret EdDSA key. You have to set, if only the hash values should be signed, or if every chunk should be signed.
    #[clap(short='S', long="sign-data", global=true, arg_enum, default_value="none")]
    sign_data: SignatureFlagValues,

    /// Your secret EdDSA key, base64 formatted.
    #[clap(short='k', long="eddsa-keypair", global=true, required=false)]
    sign_keypair: Option<String>,

    /// The case number.
    #[clap(short='c', long="case-number", global=true, required=false)]
    case_number: Option<String>,

    /// The evidence number.
    #[clap(short='e', long="evidence-number", global=true, required=false)]
    evidence_number: Option<String>,

    /// Examiner's name.
    #[clap(short='x', long="examiner-name", global=true, required=false)]
    examiner_name: Option<String>,

    /// Some notes.
    #[clap(short='n', long="notes", global=true, required=false)]
    notes: Option<String>,

    #[clap(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// acquire a physical image
    #[clap(setting(AppSettings::ArgRequiredElseHelp))]
    Physical,
}

#[derive(ArgEnum, Clone)]
enum HashAlgorithmValues {
    Blake2b512,
    SHA256,
    SHA512,
    SHA3_256,
}

#[derive(ArgEnum, Clone)]
enum CompressionAlgorithmValues {
    /// No compression is used
    None,
    /// The zstd algorithm
    Zstd,
    /// The lz4 algorithm
    Lz4,
}

#[derive(ArgEnum, Clone)]
enum PasswordKdfValues {
    Pbkdf2Sha256Aes128Cbc,
    Pbkdf2Sha256Aes256Cbc,
}

#[derive(ArgEnum, Clone)]
enum EncryptionAlgorithmValues {
    AES128GCMSIV,
    AES256GCMSIV,
}

#[derive(ArgEnum, Clone)]
enum ChunkSize {
    #[clap(name="256B")]
    CS8,
    #[clap(name="512B")]
    CS9,
    #[clap(name="1KB")]
    CS10,
    #[clap(name="2KB")]
    CS11,
    #[clap(name="4KB")]
    CS12,
    #[clap(name="8KB")]
    CS13,
    #[clap(name="16KB")]
    CS14,
    #[clap(name="32KB")]
    CS15,
    #[clap(name="64KB")]
    CS16,
    #[clap(name="128KB")]
    CS17,
    #[clap(name="256KB")]
    CS18,
    #[clap(name="512KB")]
    CS19,
    #[clap(name="1MB")]
    CS20,
}

impl ChunkSize {
    fn get_size(&self) -> u8 {
        match self {
            ChunkSize::CS8 => 8,
            ChunkSize::CS9 => 9,
            ChunkSize::CS10 => 10,
            ChunkSize::CS11 => 11,
            ChunkSize::CS12 => 12,
            ChunkSize::CS13 => 13,
            ChunkSize::CS14 => 14,
            ChunkSize::CS15 => 15,
            ChunkSize::CS16 => 16,
            ChunkSize::CS17 => 17,
            ChunkSize::CS18 => 18,
            ChunkSize::CS19 => 19,
            ChunkSize::CS20 => 20,
        }
    }
}

#[derive(ArgEnum, Clone)]
enum SignatureFlagValues {
    #[clap(name="none")]
    NoSignatures,
    #[clap(name="hash_value_signature_only")]
    HashValueSignatureOnly,
    #[clap(name="per_chunk_signatures")]
    PerChunkSignatures,
}

fn signer(args: &Cli) -> Option<Keypair> {
    match args.sign_data {
        SignatureFlagValues::NoSignatures => return None,
        _ => ()
    }

    match &args.sign_keypair {
        None => return Some(Signature::new_keypair()),
        Some(value) => match Signature::new_keypair_from_base64(value.trim()) {
            Ok(keypair) => return Some(keypair),
            Err(_) => {
                println!("{}", ERROR_PARSE_KEY);
                exit(EXIT_STATUS_ERROR);
            }
        }
    }
}

fn compression_header(args: &Cli) -> CompressionHeader {
    let compression_algorithm = match args.compression_algorithm {
        CompressionAlgorithmValues::None => CompressionAlgorithm::None,
        CompressionAlgorithmValues::Zstd => CompressionAlgorithm::Zstd,
        CompressionAlgorithmValues::Lz4 => CompressionAlgorithm::Lz4,
    };
    if args.compression_level > 9 {
        println!("error: Invalid value for '--compression-level <COMPRESSION_LEVEL>': number <{}> too large to fit in target type. (Possible values are 1-9)", args.compression_level);
        exit(EXIT_STATUS_ERROR);    
    } else if args.compression_level  < 1 {
        println!("error: Invalid value for '--compression-level <COMPRESSION_LEVEL>': number <{}> too small to fit in target type. (Possible values are 1-9)", args.compression_level);
        exit(EXIT_STATUS_ERROR);
    }
    CompressionHeader::new(DEFAULT_HEADER_VERSION_COMPRESSION_HEADER, compression_algorithm, args.compression_level, args.compression_threshold)
}

/// returns the encryption header and the encryption key.
fn encryption_header(args: &Cli) -> Option<(EncryptionHeader, Vec<u8>)> {
    let password = args.encryption_password.as_ref()?;
    let (kdf, pbes) = match args.password_kdf {
        PasswordKdfValues::Pbkdf2Sha256Aes128Cbc => (KDFScheme::PBKDF2SHA256, PBEScheme::AES128CBC),
        PasswordKdfValues::Pbkdf2Sha256Aes256Cbc => (KDFScheme::PBKDF2SHA256, PBEScheme::AES256CBC),
    };
    let encryption_algorithm = match args.encryption_algorithm {
        EncryptionAlgorithmValues::AES128GCMSIV => EncryptionAlgorithm::AES128GCMSIV,
        EncryptionAlgorithmValues::AES256GCMSIV => EncryptionAlgorithm::AES256GCMSIV,
    };
    let encryption_key = match encryption_algorithm {
        EncryptionAlgorithm::AES128GCMSIV => Encryption::gen_random_key(128),
        EncryptionAlgorithm::AES256GCMSIV => Encryption::gen_random_key(256),
        _ => {
            println!("{}", ERROR_UNKNOWN_ENCRYPTION_ALGORITHM);
            exit(EXIT_STATUS_ERROR)
        },
    };
    let (pbe_header, encrypted_encryption_key) = match kdf {
        KDFScheme::PBKDF2SHA256 => {
            let pbe_nonce = Encryption::gen_random_iv();
            let iterations = u16::MAX;
            let salt = Encryption::gen_random_salt();
            let kdf_parameters = KDFParameters::PBKDF2SHA256Parameters(PBKDF2SHA256Parameters::new(iterations, salt));
            let pbe_header = PBEHeader::new(DEFAULT_HEADER_VERSION_PBE_HEADER, kdf, pbes.clone(), kdf_parameters, pbe_nonce);
            let encrypted_encryption_key = match pbes {
                PBEScheme::AES128CBC => match Encryption::encrypt_pbkdf2sha256_aes128cbc(
                    iterations,
                    &salt,
                    &pbe_nonce,
                    password.trim(),
                    &encryption_key,
                    ) {
                    Ok(val) => val,
                    Err(_) => {
                        println!("{}", ERROR_ENCRYPT_KEY);
                        exit(EXIT_STATUS_ERROR);
                    },
                },
                PBEScheme::AES256CBC => match Encryption::encrypt_pbkdf2sha256_aes256cbc(
                    iterations,
                    &salt,
                    &pbe_nonce,
                    password.trim(),
                    &encryption_key,
                    ) {
                    Ok(val) => val,
                    Err(_) => {
                        println!("{}", ERROR_ENCRYPT_KEY);
                        exit(EXIT_STATUS_ERROR);
                    }
                },
                _ => {
                    println!("{}", ERROR_UNKNOWN_PASSWORD_KDF);
                    exit(EXIT_STATUS_ERROR)
                },
            };
            (pbe_header, encrypted_encryption_key)
        },
        _ => {
            println!("{}", ERROR_UNKNOWN_PASSWORD_KDF);
            exit(EXIT_STATUS_ERROR)
        },
    };
    let encryption_header = EncryptionHeader::new(
        DEFAULT_HEADER_VERSION_ENCRYPTION_HEADER,
        pbe_header,
        encryption_algorithm,
        encrypted_encryption_key,
        Encryption::gen_random_header_nonce()
        );
    return Some((encryption_header, encryption_key));
}

fn description_header(args: &Cli) -> DescriptionHeader {
    let mut description_header = DescriptionHeader::new_empty(DEFAULT_HEADER_VERSION_DESCRIPTION_HEADER);
    if let Some(value) = &args.case_number {
        description_header.set_case_number(value);
    };
    if let Some(value) = &args.evidence_number {
        description_header.set_evidence_number(value);
    };
    if let Some(value) = &args.examiner_name {
        description_header.set_examiner_name(value);
    };
    if let Some(value) = &args.notes {
        description_header.set_notes(value);
    };
    description_header
}

fn main() {
    let args = Cli::parse();

    // -- MainHeader:
    let chunk_size = &args.chunk_size.get_size();
    let segment_size = match hrs_parser(&args.segment_size) {
        Some(val) => val,
        None => {
            println!("{}{}", ERROR_UNPARSABLE_SEGMENT_SIZE_VALUE, &args.segment_size);
            exit(EXIT_STATUS_ERROR);
        }
    };
    let unique_segment_identifier: i64 = {
        let mut rng = rand::thread_rng();
        rng.gen()
    };

    let main_header = MainHeader::new(
        DEFAULT_HEADER_VERSION_MAIN_HEADER,
        *chunk_size,
        segment_size,
        unique_segment_identifier);
    // --

    // -- ZffCreator
    // --- object header
    let (encryption_header, encryption_key) = match encryption_header(&args) {
        Some((header, key)) => (Some(header), Some(key)),
        None => (None, None)
    };
    let compression_header = compression_header(&args);
    let signature_flag = match &args.sign_data {
        SignatureFlagValues::NoSignatures => SignatureFlag::NoSignatures,
        SignatureFlagValues::HashValueSignatureOnly => SignatureFlag::HashValueSignatureOnly,
        SignatureFlagValues::PerChunkSignatures => SignatureFlag::PerChunkSignatures,
    };

    let object_header = {
        let object_number = match &args.command {
            Commands::Physical => INITIAL_OBJECT_NUMBER
        };
        let description_header = description_header(&args);
        let object_type = match &args.command {
            Commands::Physical => ObjectType::Physical
        };
        ObjectHeader::new(DEFAULT_HEADER_VERSION_OBJECT_HEADER, object_number, encryption_header, compression_header, signature_flag, description_header, object_type)
    };

    let input_data = match File::open(&args.inputfile) {
        Ok(f) => f,
        Err(e) => {
            println!("{}{}\n{}", ERROR_OPEN_INPUT_FILE, &args.inputfile, e.to_string());
            exit(EXIT_STATUS_ERROR);
        }
    };

    let mut hash_types = Vec::new();
    for htype in &args.hash_algorithm {
        match htype {
            HashAlgorithmValues::Blake2b512 => hash_types.push(HashType::Blake2b512),
            HashAlgorithmValues::SHA256 => hash_types.push(HashType::SHA256),
            HashAlgorithmValues::SHA512 => hash_types.push(HashType::SHA512),
            HashAlgorithmValues::SHA3_256 => hash_types.push(HashType::SHA3_256),
        }
    }

    let sign_keypair = signer(&args);

    let output_filepath = args.outputfile;

    match args.command {
        Commands::Physical => {
            let mut zffcreator = match ZffCreatorPhysical::new(
                                            object_header,
                                            input_data, 
                                            hash_types,
                                            encryption_key,
                                            sign_keypair,
                                            main_header,
                                            args.encrypted_header,
                                            args.description_notes,
                                            output_filepath) {
                Ok(zffcreator) => zffcreator,
                Err(e) => {
                    println!("{ERROR_CREATE_OBJECT_ENCODER}, {e}");
                    exit(EXIT_STATUS_ERROR);
                }

            };
            match zffcreator.generate_files() {
                Ok(()) => exit(EXIT_STATUS_SUCCESS),
                Err(e) => {
                    println!("{ERROR_GENERATE_FILES}{e}");
                    exit(EXIT_STATUS_ERROR);
                }
            }
        }
    }
}